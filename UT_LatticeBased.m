function [Xu] = UT_LatticeBased(modeltype, ModelPar)
% UT_LatticeBased - Generates base station locations based on model
% parameters and the model type
% 
% Syntax: [Xu] = UT_LatticeBased(modeltype, ModelPar)
%
% Inputs:
%   modeltype - the type of model to generate. Model types can be found in
%   additional info.
%   ModelPar - the model paramters structure generated by the ModelParaSet
%   function
% 
% Outputs:
%   Xu - the base station locations
%
% Other m-files required: Polygon_rx_ry.m
% Subfunctions:
%   [X_peterbed] = Add_Perterbation(type, Xu, alpha) - adds perterbation to the point
%   [X_up] = AddUniPerterb(X,r) - to add uniform perterbation 
%   [X_Gp] = AddGaussianPerterb(X,Std) - to add Gaussian Perterbation
%   [X_t] = AddRandomShift(etta, Xu) - adds equal random translation to all points of the lattice
% MAT-files required: none
%
% Additional Info:
%   Model Parameters:
%       win - the study region
%       lambda - the density of the points per 1 m^2
%       alpha_norm - the normalized perterbation distance
%       r_norm - the normalized hard-core distance
%       gama - TODO
%       metric - the CoV metric. Options are: 'CN', 'CV', 'CD', or 'All'
%   Type of models
%       [1] Peterbed lattice models 
%       hexUni        Hexagonal Layout with uniform perterbation 
%       hexGau        Hexagonal Layout with Gaussian perterbation 
%       sqUni         Square layout with uniform perterbation
%       sqGau         Square layout with Gaussian perterbation
%       SSI
%       MHCI
%       MHCII

    K = 1; %  study region scaling factor. its purpuse is to guarantee enough points (no gaps) in the study region due to tilting the points using the generation matrix
           % In fact, We  needed this factor in the first edition of this code. Now, we rarly need this factor sinc we generate square grid with very high density and scale it with the factor 
           % alph=1/sqrt(lambda).
           % we may need this factor if we have very small window

    % Get model parameters
    lambda = ModelPar.lambda; 
    alpha_norm = ModelPar.alpha_norm; 
    win = ModelPar.win; 
    [rx, ry] = Polygon_rx_ry(win);

    % Calculate the Min, Max , and range values 
    xMin = ModelPar.win(1); xMax = ModelPar.win(2);
    yMin = ModelPar.win(3); yMax = ModelPar.win(4);
    cx = xMax-xMin;         cy = yMax - yMin;

    % Step 1: &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
    % Generate integer  lattice (simple square lattice with density 1. )
    X_reso = cx + 1;
    Y_reso = cy + 1; 
    X_edgeLength = 1;
    Y_edgeLength = 1;
    xl = X_edgeLength/2 + linspace(K*xMin,K*xMax,K*X_reso)'; 
    yl = Y_edgeLength/2 + linspace(K*yMin,K*yMax,K*Y_reso)';
    xl=xl(1:end-1);
    yl=yl(1:end-1);
    [Xm,Ym] = meshgrid(xl,yl);
    XL=Xm(:);
    YL=Ym(:);
    U= [XL YL];    % U is the cordinates of the Simple square lattice ( Nx2 Matrix) 
    % end of Step 1 &&&&&&&&&&&&&&&&&&&&&&&&
    %=============================

    %Step 2 &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
    % Generate the required grid with the required density using the simple
    % square grid
    %==================
    % Adding random translation (equal shift to all points to make the lattice
    % stationary
    % Xu=AddRandomShift(etta, Xu); 
    % ===============
    switch modeltype
        case {'hexUni', 'hexGau'}
            Ghex = [1 0.5; 0 sqrt(3)/ 2]'; % generation Matrix
            etta = 1/sqrt(lambda*abs(det(Ghex)));
            alpha = alpha_norm*etta;
            U = AddRandomShift(etta, U); 
            X_hex = etta*U*Ghex;
            Xu = X_hex;
            Padding = (1+2*alpha/min(cx,cy));
        case {'sqUni', 'sqGau'}
            Gsq = eye(2);
            etta = 1/sqrt(lambda*abs(det(Gsq)));
            alpha = alpha_norm*etta;
            U = AddRandomShift(etta, U);
            X_s = etta*U*Gsq; % cordinates of a square Lattice 
            Xu = X_s;
            Padding = (1+2*5*alpha/min(cx,cy));
    end
    % end of Step 2 &&&&&&&&&&&&&&&&&&&&&&&&&
    %============================

    inp = inpolygon(Xu(:,1),Xu(:,2),Padding*rx,Padding*ry);
    Xu = Xu(inp,:);

    % ==============
    % add perterpation 
    Xu = Add_Perterbation(modeltype, Xu, alpha);        
    inp2 = inpolygon(Xu(:,1),Xu(:,2),rx,ry);
    Xu = Xu(inp2,:);
    %=========================

    % Subfunctions
    %[1]========================================
    % this function adds random perterbation 
    % it has two sub functions 
    %  [X_up] = AddUniPerterb(X,r) to add uniform perterbation 
    %  [X_Gp] = AddGaussianPerterb(X,Std) to add Gaussian Perterbation 
    function [X_peterbed] = Add_Perterbation(type, Xu, alpha)
    % Add_Perterbation  : this function adds perterbation to the point
    % locations.
    
        switch type
            case { 'hexUni', 'sqUni'}
                X_peterbed = AddUniPerterb(Xu,alpha); 
            case{'hexGau', 'sqGau'}
                X_peterbed = AddGaussianPerterb(Xu,alpha);  
        end
        
        % Uniform perturbation on a disk of radius r
        function [X_up] = AddUniPerterb(X,r)
            % Uniform perturbation on a disck of radious r
            Lx = size(X,1); 
            th = 2*pi.*rand(Lx,1);
            R = r.*sqrt(rand(Lx,1));
            [xc,yc] = pol2cart(th,R);
            X_up = X + [xc,yc];
        end
        % Gaussian Perturbation
        function [X_Gp] = AddGaussianPerterb(X,Std)
            % Gaussian Perturbation 
            Lx = length(X); 
            Sigma = Std.*eye(2); 
            Xper = randn(Lx,2)*Sigma;
            X_Gp = X+Xper;
        end
    end
    % end of the function X_peterbed=Add_Perterbation(type, Xu, alpha)
    %===============================


    % [2] ===============================
    % Add Random Shift
    % this function adds equal random translation to all points of the lattice
    function [X_t] = AddRandomShift(etta, Xu)
        L=size(Xu,1);
        Random_Translation = -0.5*etta + etta*rand(1,2); 
        Random_Translation = repmat(Random_Translation,L,1);
        X_t = Xu + Random_Translation; 
    end
    % end of the function X_t=AddRandomShift(etta, Xu)
    % ==================
    
end % end of the function Xu=UT_LatticeBased(modeltype, ModelPar)

%  /* Copyright (C) 2016 Faraj Lagum @ Carleton University - All Rights Reserved
%   You may use and modify this code, but not to distribute it.  
%  If You don't have a license to use this code, please write to:
%  faraj.lagum@sce.carleton.ca. */
